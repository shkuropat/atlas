// Code generated by protoc-gen-go. DO NOT EDIT.
// source: service_control_plane.proto

package atlas

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("service_control_plane.proto", fileDescriptor_144c4e5d826a1f85) }

var fileDescriptor_144c4e5d826a1f85 = []byte{
	// 233 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x90, 0x41, 0x4b, 0x03, 0x31,
	0x10, 0x85, 0xad, 0x50, 0x85, 0x71, 0x0b, 0x65, 0x7a, 0x8b, 0x37, 0x2f, 0x0a, 0xc2, 0x22, 0x0a,
	0x42, 0xcf, 0xf5, 0xa8, 0x28, 0xa8, 0xe7, 0x30, 0x4d, 0x03, 0xae, 0x8d, 0x9b, 0x25, 0x33, 0xf5,
	0x87, 0xf8, 0x8b, 0x25, 0xc9, 0x20, 0x2d, 0xee, 0xf1, 0xbd, 0xbc, 0x2f, 0xef, 0x31, 0x70, 0xce,
	0x3e, 0x7d, 0x77, 0xce, 0x5b, 0x17, 0x7b, 0x49, 0x31, 0xd8, 0x21, 0x50, 0xef, 0xdb, 0x21, 0x45,
	0x89, 0x38, 0x25, 0x09, 0xc4, 0x66, 0xbe, 0x21, 0x21, 0xeb, 0x3e, 0x76, 0xfd, 0xb6, 0x3e, 0x98,
	0xe6, 0xcb, 0x4b, 0xea, 0x9c, 0x2a, 0x8c, 0xeb, 0x4f, 0xef, 0x84, 0x6d, 0xe8, 0x58, 0xd4, 0x5b,
	0x54, 0xcf, 0xb2, 0x90, 0xec, 0x58, 0x4d, 0x10, 0x62, 0xfd, 0xe2, 0xf6, 0xe7, 0x18, 0x9a, 0x55,
	0xed, 0x7c, 0xc9, 0x95, 0x78, 0x09, 0xd3, 0x37, 0xe2, 0x2d, 0xe3, 0x59, 0x5b, 0x6a, 0xdb, 0xac,
	0xcc, 0xbe, 0xb8, 0x38, 0xba, 0x9a, 0xdc, 0x4c, 0xf0, 0x1e, 0xe0, 0x81, 0x84, 0x56, 0x79, 0x0f,
	0xe3, 0x5c, 0x03, 0x7f, 0x96, 0xf9, 0xe7, 0x28, 0xb7, 0x84, 0xe6, 0x7d, 0x08, 0x91, 0x36, 0xcf,
	0x65, 0xda, 0x08, 0xb9, 0x50, 0xa7, 0x06, 0x5e, 0xcb, 0xf4, 0x0c, 0xe3, 0x12, 0x66, 0xfb, 0xe8,
	0x58, 0x2b, 0x1e, 0xb0, 0xfc, 0xd8, 0xb1, 0x14, 0xf4, 0x1a, 0x4e, 0x9f, 0xca, 0xb1, 0x18, 0x67,
	0x1a, 0xa9, 0xda, 0x1c, 0xca, 0x1c, 0x5e, 0x9f, 0x94, 0xdb, 0xdc, 0xfd, 0x06, 0x00, 0x00, 0xff,
	0xff, 0xfb, 0xdd, 0x13, 0x9a, 0x96, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ControlPlaneClient is the client API for ControlPlane service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ControlPlaneClient interface {
	//*
	// Bi-directional Commands stream.
	// Commands are sent from service to client and from client to server
	Tasks(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_TasksClient, error)
	//*
	// Bi-directional Data stream.
	// Some commands may be followed by data load. Be it logs, dumps, etc.
	DataChunks(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_DataChunksClient, error)
	UploadObject(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_UploadObjectClient, error)
	UploadObjects(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_UploadObjectsClient, error)
	//*
	// Uni-directional Metrics stream from client to server.
	Metrics(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_MetricsClient, error)
}

type controlPlaneClient struct {
	cc *grpc.ClientConn
}

func NewControlPlaneClient(cc *grpc.ClientConn) ControlPlaneClient {
	return &controlPlaneClient{cc}
}

func (c *controlPlaneClient) Tasks(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_TasksClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ControlPlane_serviceDesc.Streams[0], "/atlas.ControlPlane/Tasks", opts...)
	if err != nil {
		return nil, err
	}
	x := &controlPlaneTasksClient{stream}
	return x, nil
}

type ControlPlane_TasksClient interface {
	Send(*Task) error
	Recv() (*Task, error)
	grpc.ClientStream
}

type controlPlaneTasksClient struct {
	grpc.ClientStream
}

func (x *controlPlaneTasksClient) Send(m *Task) error {
	return x.ClientStream.SendMsg(m)
}

func (x *controlPlaneTasksClient) Recv() (*Task, error) {
	m := new(Task)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *controlPlaneClient) DataChunks(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_DataChunksClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ControlPlane_serviceDesc.Streams[1], "/atlas.ControlPlane/DataChunks", opts...)
	if err != nil {
		return nil, err
	}
	x := &controlPlaneDataChunksClient{stream}
	return x, nil
}

type ControlPlane_DataChunksClient interface {
	Send(*DataChunk) error
	Recv() (*DataChunk, error)
	grpc.ClientStream
}

type controlPlaneDataChunksClient struct {
	grpc.ClientStream
}

func (x *controlPlaneDataChunksClient) Send(m *DataChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *controlPlaneDataChunksClient) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *controlPlaneClient) UploadObject(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_UploadObjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ControlPlane_serviceDesc.Streams[2], "/atlas.ControlPlane/UploadObject", opts...)
	if err != nil {
		return nil, err
	}
	x := &controlPlaneUploadObjectClient{stream}
	return x, nil
}

type ControlPlane_UploadObjectClient interface {
	Send(*DataChunk) error
	CloseAndRecv() (*ObjectStatus, error)
	grpc.ClientStream
}

type controlPlaneUploadObjectClient struct {
	grpc.ClientStream
}

func (x *controlPlaneUploadObjectClient) Send(m *DataChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *controlPlaneUploadObjectClient) CloseAndRecv() (*ObjectStatus, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ObjectStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *controlPlaneClient) UploadObjects(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_UploadObjectsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ControlPlane_serviceDesc.Streams[3], "/atlas.ControlPlane/UploadObjects", opts...)
	if err != nil {
		return nil, err
	}
	x := &controlPlaneUploadObjectsClient{stream}
	return x, nil
}

type ControlPlane_UploadObjectsClient interface {
	Send(*DataChunk) error
	CloseAndRecv() (*ObjectsList, error)
	grpc.ClientStream
}

type controlPlaneUploadObjectsClient struct {
	grpc.ClientStream
}

func (x *controlPlaneUploadObjectsClient) Send(m *DataChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *controlPlaneUploadObjectsClient) CloseAndRecv() (*ObjectsList, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ObjectsList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *controlPlaneClient) Metrics(ctx context.Context, opts ...grpc.CallOption) (ControlPlane_MetricsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ControlPlane_serviceDesc.Streams[4], "/atlas.ControlPlane/Metrics", opts...)
	if err != nil {
		return nil, err
	}
	x := &controlPlaneMetricsClient{stream}
	return x, nil
}

type ControlPlane_MetricsClient interface {
	Send(*Metric) error
	CloseAndRecv() (*Metric, error)
	grpc.ClientStream
}

type controlPlaneMetricsClient struct {
	grpc.ClientStream
}

func (x *controlPlaneMetricsClient) Send(m *Metric) error {
	return x.ClientStream.SendMsg(m)
}

func (x *controlPlaneMetricsClient) CloseAndRecv() (*Metric, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Metric)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ControlPlaneServer is the server API for ControlPlane service.
type ControlPlaneServer interface {
	//*
	// Bi-directional Commands stream.
	// Commands are sent from service to client and from client to server
	Tasks(ControlPlane_TasksServer) error
	//*
	// Bi-directional Data stream.
	// Some commands may be followed by data load. Be it logs, dumps, etc.
	DataChunks(ControlPlane_DataChunksServer) error
	UploadObject(ControlPlane_UploadObjectServer) error
	UploadObjects(ControlPlane_UploadObjectsServer) error
	//*
	// Uni-directional Metrics stream from client to server.
	Metrics(ControlPlane_MetricsServer) error
}

// UnimplementedControlPlaneServer can be embedded to have forward compatible implementations.
type UnimplementedControlPlaneServer struct {
}

func (*UnimplementedControlPlaneServer) Tasks(srv ControlPlane_TasksServer) error {
	return status.Errorf(codes.Unimplemented, "method Tasks not implemented")
}
func (*UnimplementedControlPlaneServer) DataChunks(srv ControlPlane_DataChunksServer) error {
	return status.Errorf(codes.Unimplemented, "method DataChunks not implemented")
}
func (*UnimplementedControlPlaneServer) UploadObject(srv ControlPlane_UploadObjectServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadObject not implemented")
}
func (*UnimplementedControlPlaneServer) UploadObjects(srv ControlPlane_UploadObjectsServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadObjects not implemented")
}
func (*UnimplementedControlPlaneServer) Metrics(srv ControlPlane_MetricsServer) error {
	return status.Errorf(codes.Unimplemented, "method Metrics not implemented")
}

func RegisterControlPlaneServer(s *grpc.Server, srv ControlPlaneServer) {
	s.RegisterService(&_ControlPlane_serviceDesc, srv)
}

func _ControlPlane_Tasks_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ControlPlaneServer).Tasks(&controlPlaneTasksServer{stream})
}

type ControlPlane_TasksServer interface {
	Send(*Task) error
	Recv() (*Task, error)
	grpc.ServerStream
}

type controlPlaneTasksServer struct {
	grpc.ServerStream
}

func (x *controlPlaneTasksServer) Send(m *Task) error {
	return x.ServerStream.SendMsg(m)
}

func (x *controlPlaneTasksServer) Recv() (*Task, error) {
	m := new(Task)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ControlPlane_DataChunks_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ControlPlaneServer).DataChunks(&controlPlaneDataChunksServer{stream})
}

type ControlPlane_DataChunksServer interface {
	Send(*DataChunk) error
	Recv() (*DataChunk, error)
	grpc.ServerStream
}

type controlPlaneDataChunksServer struct {
	grpc.ServerStream
}

func (x *controlPlaneDataChunksServer) Send(m *DataChunk) error {
	return x.ServerStream.SendMsg(m)
}

func (x *controlPlaneDataChunksServer) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ControlPlane_UploadObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ControlPlaneServer).UploadObject(&controlPlaneUploadObjectServer{stream})
}

type ControlPlane_UploadObjectServer interface {
	SendAndClose(*ObjectStatus) error
	Recv() (*DataChunk, error)
	grpc.ServerStream
}

type controlPlaneUploadObjectServer struct {
	grpc.ServerStream
}

func (x *controlPlaneUploadObjectServer) SendAndClose(m *ObjectStatus) error {
	return x.ServerStream.SendMsg(m)
}

func (x *controlPlaneUploadObjectServer) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ControlPlane_UploadObjects_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ControlPlaneServer).UploadObjects(&controlPlaneUploadObjectsServer{stream})
}

type ControlPlane_UploadObjectsServer interface {
	SendAndClose(*ObjectsList) error
	Recv() (*DataChunk, error)
	grpc.ServerStream
}

type controlPlaneUploadObjectsServer struct {
	grpc.ServerStream
}

func (x *controlPlaneUploadObjectsServer) SendAndClose(m *ObjectsList) error {
	return x.ServerStream.SendMsg(m)
}

func (x *controlPlaneUploadObjectsServer) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ControlPlane_Metrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ControlPlaneServer).Metrics(&controlPlaneMetricsServer{stream})
}

type ControlPlane_MetricsServer interface {
	SendAndClose(*Metric) error
	Recv() (*Metric, error)
	grpc.ServerStream
}

type controlPlaneMetricsServer struct {
	grpc.ServerStream
}

func (x *controlPlaneMetricsServer) SendAndClose(m *Metric) error {
	return x.ServerStream.SendMsg(m)
}

func (x *controlPlaneMetricsServer) Recv() (*Metric, error) {
	m := new(Metric)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ControlPlane_serviceDesc = grpc.ServiceDesc{
	ServiceName: "atlas.ControlPlane",
	HandlerType: (*ControlPlaneServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Tasks",
			Handler:       _ControlPlane_Tasks_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DataChunks",
			Handler:       _ControlPlane_DataChunks_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UploadObject",
			Handler:       _ControlPlane_UploadObject_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UploadObjects",
			Handler:       _ControlPlane_UploadObjects_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Metrics",
			Handler:       _ControlPlane_Metrics_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "service_control_plane.proto",
}
